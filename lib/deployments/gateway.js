const Deployment = require('./base');
const slug = require('slug');
const debug = require('debug')('actualizer:gateway');
const jsYaml = require('js-yaml');
const hash = require('object-hash');
const defaultModels = require('./gateway-default-models');
slug.defaults.mode = 'rfc3986';

const GATEWAY_IMAGE = process.env.GATEWAY_IMAGE || 'expressgateway/express-gateway';
const GATEWAY_VERSION = process.env.GATEWAY_VERSION || 'latest';
const ADMIN_CROSS_ORIGIN = process.env.ADMIN_CROSS_ORIGIN || '*';
const DEBUG_GATEWAY_VERSION = process.env.DEBUG_GATEWAY_VERSION || GATEWAY_VERSION;
const usersInDebugMode = process.env.LB_DEBUG_USERS ? process.env.LB_DEBUG_USERS.split(',') : [];
const AUTOGATEWAY_ENABLE = process.env.AUTOGATEWAY_ENABLE || false;
const keys = Object.keys(defaultModels);
for (const k of keys) {
  defaultModels[k] = JSON.stringify(defaultModels[k]);
}
const defaultSystemConfig = {
  db: {
    redis: {
      /* eslint-disable no-template-curly-in-string */
      host: '${REDIS_HOST}',
      port: '${REDIS_PORT}',
      password: '${REDIS_PASSWORD}',
      namespace: '${EG_NAMESPACE}'
      /* eslint-enable no-template-curly-in-string */
    }
  },
  crypto: {
    cipherKey: 'sensitiveKey',
    algorithm: 'aes256',
    saltRounds: 10
  },
  session: {
    secret: 'keyboard cat',
    resave: false,
    saveUninitialized: false
  },
  accessTokens: {
    timeToExpiry: 7200000
  },
  refreshTokens: {
    timeToExpiry: 7200000
  },
  authorizationCodes: {
    timeToExpiry: 7200000
  }
};

module.exports = function load (producer, env, project, models, _, domain, slsFunctions, openAPISpec) {
  if (!project) return [];

  let autoGeneratedPaths;
  let enableRateLimit = false;
  if (openAPISpec && openAPISpec.paths && Object.keys(openAPISpec.paths).length) {
    autoGeneratedPaths = Object.keys(openAPISpec.paths).map(x => x.replace(/{.*?}/g, '*'));
    if (!autoGeneratedPaths || !autoGeneratedPaths.length) {
      autoGeneratedPaths = ['*'];
    }
  }
  if (openAPISpec && openAPISpec.definitions) {
    // simple solution to find if any property is of type byte
    const str = JSON.stringify(openAPISpec.definitions);
    enableRateLimit = str.indexOf('byte') >= 0 || str.indexOf('binary') >= 0;
  }
  const deployments = [];
  for (const id of Object.keys(project.gateways)) {
    deployments.push(new GatewayDeployment(project, models, id, producer, env, domain, slsFunctions));
  }

  // Auto Gateway is self configured gateway that exposes loopback
  if (AUTOGATEWAY_ENABLE && autoGeneratedPaths) {
    deployments.push(new AutoGatewayDeployment({project, models, producer, env, domain, slsFunctions, autoGeneratedPaths, enableRateLimit}));
  }

  return deployments;
};
class AutoGatewayDeployment extends Deployment {
  constructor ({project, models, producer, env, domain, slsFunctions, autoGeneratedPaths, enableRateLimit}) {
    super();
    this.dnsPrefix = 'lunchbadger.io';
    this.producer = producer;
    this.env = env;
    this.id = producer + env + '0000';
    this.name = this.prepareName('AutoGenerated', this.id);
    this.slug = `${slug(this.name)}-${this.producer}-${this.env}`;
    this.adminHost = `admin-${this.slug}.${domain}`;
    this.gatewayConfig = {
      serviceEndpoints: {},
      apiEndpoints: {},
      pipelines: {},
      policies: ['cors', 'proxy', 'key-auth', 'jwt', 'rate-limit']
    };
    this.gatewayConfig.apiEndpoints['api'] = {
      host: `${this.slug}.${domain}`,
      paths: autoGeneratedPaths,
      scopes: ['api:readonly']
    };
    this.gatewayConfig.serviceEndpoints['api'] = {
      friendlyName: 'api',
      url: `http://workspace-${this.producer}-${this.env}.customer:3000/api`
    };

    this.gatewayConfig.http = {
      host: '*',
      port: 8080
    };

    this.gatewayConfig.admin = {
      hostname: '0.0.0.0',
      port: 9876
    };

    this.gatewayConfig.apiEndpoints['admin'] = {
      host: this.adminHost
    };

    this.gatewayConfig.serviceEndpoints['admin'] = {
      url: 'http://localhost:9876'
    };
    this.gatewayConfig.pipelines['admin'] = {
      apiEndpoints: [
        'admin'
      ],
      policies: [
        {
          cors: [
            {
              action: {
                credentials: true,
                origin: ADMIN_CROSS_ORIGIN
              }
            }
          ]
        },
        {
          proxy: [
            {
              action: {
                changeOrigin: true,
                serviceEndpoint: 'admin'
              }
            }
          ]
        }
      ]
    };

    this.gatewayConfig.pipelines['api'] = {
      apiEndpoints: [
        'api'
      ],
      policies: [
        {
          'key-auth': [{
            action: {
              apiKeyHeader: 'Authorization',
              apiKeyHeaderScheme: '',
              disableHeadersScheme: true
            }
          }]
        },
        {
          proxy: [
            {
              action: {
                changeOrigin: true,
                serviceEndpoint: 'api'
              }
            }
          ]
        }
      ]
    };
    if (enableRateLimit) {
      this.gatewayConfig.pipelines['api'].policies.splice(1, 0,
        {
          'rate-limit': [
            {
              action: {
                max: 10,
                windowMs: 120000
              }
            }]
        });
    }
    this.gatewayConfigHash = hash(this.gatewayConfig);
  }

  getConfigFiles () {
    debug('CONFIG', this.gatewayConfig);

    return {
      'gateway.config.yml': jsYaml.dump(this.gatewayConfig),
      'system.config.yml': jsYaml.dump(Object.assign({}, defaultSystemConfig, this.systemConfig)),
      'users.json': defaultModels['users.json'],
      'applications.json': defaultModels['applications.json'],
      'credentials.json': defaultModels['credentials.json']
    };
  }

  getVolumes (configMap) {
    return [{
      name: 'ro-configmap',
      configMap: {
        name: configMap.metadata.name
      }
    },
    {
      name: 'config',
      emptyDir: {}
    }];
  }

  getInitContainersSpec () {
    return [{
      name: "copy-ro-configmap",
      image: "alpine",
      command: [
        "sh",
        "-c",
        "cp /tmp/gateway.config.yml /usr/src/app/lib/config/gateway.config.yml && cp /tmp/system.config.yml /usr/src/app/lib//config/system.config.yml && cp /tmp/users.json /usr/src/app/lib/config/models/users.json && cp /tmp/applications.json /usr/src/app/lib/config/models/applications.json && cp /tmp/credentials.json /usr/src/app/lib/config/models/credentials.json "
      ],
      volumeMounts: [
        {
					mountPath: "/tmp/system.config.yml",
					name: "ro-configmap",
					subPath: "system.config.yml"
				},
				{
					mountPath: "/tmp/gateway.config.yml",
					name: "ro-configmap",
					subPath: "gateway.config.yml"
				},
				{
					mountPath: "/tmp/users.json",
					name: "ro-configmap",
					subPath: "users.json"
				},
				{
					mountPath: "/tmp/applications.json",
					name: "ro-configmap",
					subPath: "applications.json"
				},
				{
					mountPath: "/tmp/credentials.json",
					name: "ro-configmap",
					subPath: "credentials.json"
        },
        {
          mountPath: "/usr/src/app/lib/config",
          name: "config",
        },
        {
          mountPath: "/usr/src/app/lib/config/models",
          name: "config",
        }
      ]
    }] ;
  }

  getContainerSpec () {
    const version = usersInDebugMode.indexOf(this.producer) === -1 ? GATEWAY_VERSION : DEBUG_GATEWAY_VERSION;

    return [{
      name: 'gateway',
      image: `${GATEWAY_IMAGE}:${version}`,
      readinessProbe: {
        tcpSocket: {
          port: 8080
        },
        initialDelaySeconds: 5,
        timeoutSeconds: 10,
        periodSeconds: 10,
        successThreshold: 2,
        failureThreshold: 3
      },
      env: [
        {
          name: 'LB_PRODUCER',
          value: this.producer
        },
        {
          name: 'EG_CONFIG_DIR',
          value: '/usr/src/app/lib/config'
        },
        {
          name: 'LOG_LEVEL',
          value: 'debug'
        },
        {
          name: 'REDIS_HOST',
          value: process.env.REDIS_HOST || 'eg-identity-redis.default'
        },
        {
          name: 'REDIS_PORT',
          value: process.env.REDIS_PORT || '6379'
        },
        {
          name: 'REDIS_PASSWORD',
          value: process.env.REDIS_PASSWORD
        },
        {
          name: 'EG_NAMESPACE',
          value: `EG-${this.producer}-${this.env}-`
        }

      ],
      ports: [
        {
          name: 'gateway',
          containerPort: 8080
        },
        {
          name: 'admin',
          containerPort: 9876
        }
      ],
      volumeMounts: [{
        name: 'config',
        mountPath: '/usr/src/app/lib/config/system.config.yml',
        subPath: 'system.config.yml'
      }, {
        name: 'config',
        mountPath: '/usr/src/app/lib/config/gateway.config.yml',
        subPath: 'gateway.config.yml'
      }, {
        name: 'config',
        mountPath: '/usr/src/app/lib/config/models/users.json',
        subPath: 'users.json'
      }, {
        name: 'config',
        mountPath: '/usr/src/app/lib/config/models/applications.json',
        subPath: 'applications.json'
      }, {
        name: 'config',
        mountPath: '/usr/src/app/lib/config/models/credentials.json',
        subPath: 'credentials.json'
      }],
      volumes: [
        {
          name: "ro-configmap",
          configMap: { name: configMap.metadata.name }
        },
        {
          name: "config",
          emptyDir: {}
        }
      ]
    }];
  }

  getServicePorts () {
    return [{
      name: 'gateway',
      port: 8080,
      targetPort: 8080,
      protocol: 'TCP'
    },
    {
      name: 'admin',
      port: 9876,
      targetPort: 9876,
      protocol: 'TCP'
    }];
  }

  getPartialLocator () {
    return {
      producer: this.producer,
      environment: this.env,
      id: this.id,
      instance: slug(this.name),
      app: 'gateway',
      gatewayConfigHash: this.gatewayConfigHash
    };
  }

  getIngressRules (serviceName, domain) {
    return [{
      host: `${this.slug}.${domain}`,
      http: {
        paths: [{
          backend: {
            serviceName: serviceName,
            servicePort: 8080
          }
        }]
      }
    }, {
      host: `admin-${this.slug}.${domain}`,
      http: {
        paths: [{
          backend: {
            serviceName: serviceName,
            servicePort: 8080
          }
        }]
      }
    }];
  }

  getAnnotations () {
    console.log(this.gatewayConfigHash);
    return {
      'prometheus.io/scrape': 'true',
      'prometheus.io/port': '9876'
    };
  }
}
class GatewayDeployment extends Deployment {
  constructor (project, models, id, producer, env, domain, slsFunctions) {
    super();

    const gatewayJson = project.gateways[id].data;
    this.id = id;
    this.dnsPrefix = gatewayJson.dnsPrefix;
    this.producer = producer;
    this.env = env;
    this.name = this.prepareName(gatewayJson.name, id);
    this.slug = `${slug(this.name)}-${this.producer}-${this.env}`;
    this.systemConfig = gatewayJson.system;
    delete gatewayJson.system;
    this.gatewayConfig = gatewayJson;
    this.adminHost = `admin-${this.slug}.${domain}`;
    this.models = Object.create(null);
    this.slsFunctions = Object.create(null);

    if (models && models.length) {
      models.forEach(model => {
        if (model.lunchbadgerId !== undefined) {
          this.models[model.lunchbadgerId] = model;
        }
        // this.models[model.id] = model;
      });
    }

    if (slsFunctions && slsFunctions.length) {
      slsFunctions.forEach(slsFn => {
        if (slsFn && slsFn.serverless && slsFn.serverless.lunchbadger && slsFn.serverless.lunchbadger.id) {
          const ns = slsFn.serverless.provider.namespace || 'customer';
          this.slsFunctions[slsFn.serverless.lunchbadger.id] = {
            url: `http://fn-${this.producer}-${this.env}-${slsFn.serverless.service}.${ns}:8080`
          };
        }
      });
    }

    const apiEndpointKeys = Object.keys(project.apiEndpoints || {});
    this.gatewayConfig.apiEndpoints = {};

    apiEndpointKeys.forEach(key => {
      // eslint-disable-next-line
      let { id, name, host, paths } = project.apiEndpoints[key].data;

      const conn = project.connections.byTarget[key];

      const gwId = conn && conn[0] && conn[0].from && conn[0].from.gateway && conn[0].from.gateway.id;

      if (!gwId || gwId !== this.id) {
        debug(`ApiEndpoint ${key}(${name}) is not connected to Gateway ${this.id}(${gatewayJson.name})`);
        return false;
      }

      debug(`Configuring ApiEndpoint ${key}(${name}) to Gateway ${this.id}(${gatewayJson.name})`);

      if (host === '*') {
        host = `${this.slug}.${domain}`;
      }
      const obj = Object.assign({}, { host, paths });
      obj.friendlyName = name;

      this.gatewayConfig.apiEndpoints[id] = obj;
    });

    // copy paste from UI
    const connectedServiceEndpoints = Object.values(gatewayJson.pipelines)
      .reduce((map, { policies }) => [...map, ...policies], [])
      .filter(({ proxy }) => proxy)
      .reduce((map, { proxy }) => [...map, ...proxy], [])
      .filter(({ action: { serviceEndpoint } }) => serviceEndpoint)
      .map(({ action: { serviceEndpoint } }) => serviceEndpoint)
      .reduce((map, item) => ({ ...map, [item]: true }), {});

    const serviceEndpointKeys = Object.keys(project.serviceEndpoints || {});
    this.gatewayConfig.serviceEndpoints = {};
    serviceEndpointKeys.forEach(key => {
      if (!connectedServiceEndpoints[key]) { return; }
      const { id, name, urls } = project.serviceEndpoints[key].data;

      const obj = Object.assign({}, { urls });
      obj.friendlyName = name;

      if (obj.urls.length === 1) {
        obj.url = obj.urls[0];
        delete obj.urls;
      }

      this.gatewayConfig.serviceEndpoints[id] = obj;
    });

    const modelKeys = Object.keys(this.models);
    modelKeys.forEach(id => {
      if (!this.gatewayConfig.serviceEndpoints.hasOwnProperty(id)) {
        let p = this.models[id].plural || this.models[id].name;
        if (this.models[id].http && this.models[id].http.path) {
          p = this.models[id].http.path;
        }
        this.gatewayConfig.serviceEndpoints[id] = {
          friendlyName: this.models[id].name,
          url: `http://workspace-${this.producer}-${this.env}.customer:3000/api/${p}`
        };
      }
    });

    for (const slsId in this.slsFunctions) {
      if (!this.gatewayConfig.serviceEndpoints.hasOwnProperty(slsId)) {
        this.gatewayConfig.serviceEndpoints[slsId] =
        {
          url: this.slsFunctions[slsId].url
        };
      }
    }

    debug('registered service endpoints', this.gatewayConfig.serviceEndpoints);

    if (!this.gatewayConfig.pipelines) {
      this.gatewayConfig.pipelines = Object.create(null);
    }

    if (Array.isArray(this.gatewayConfig.pipelines)) {
      // Convert array of pipelines to pipeline object.
      const pipelines = Object.create(null);

      this.gatewayConfig.pipelines.forEach(pipeline => {
        const id = pipeline.id;
        delete pipeline.id;

        pipeline.friendlyName = pipeline.name;
        delete pipeline.name;

        pipelines[id] = pipeline;
      });

      this.gatewayConfig.pipelines = pipelines;
    }

    const pipelineIDs = Object.keys(this.gatewayConfig.pipelines);
    pipelineIDs.forEach(id => {
      const pipeline = this.gatewayConfig.pipelines[id];
      const bySource = project.connections.bySource[id];

      if (bySource) {
        const apiEndpoints = bySource.map(connection => {
          return connection.to.data.id;
        });
        pipeline.apiEndpoints = apiEndpoints;
      }

      pipeline.policies = pipeline.policies || [];
      pipeline.policies = pipeline.policies.map(policy => {
        delete policy.id;

        const keys = Object.keys(policy);

        keys.forEach(key => {
          const pairs = policy[key] || [];
          pairs.forEach(pair => {
            if (pair.condition && Object.keys(pair.condition).length === 0) {
              delete pair.condition;
            }
          });
        });

        return policy;
      });
    });

    // FIXME: C'mon now...
    this.gatewayConfig.policies = this.gatewayConfig.policies.map(policy => {
      if (policy === 'rate-limiter') return 'rate-limit';
      if (policy === 'simple-logger') return 'log';
      return policy;
    });

    delete this.gatewayConfig.dnsPrefix;
    delete this.gatewayConfig.itemOrder;

    this.gatewayConfig.http = {
      host: '*',
      port: 8080
    };

    this.gatewayConfig.admin = {
      hostname: '0.0.0.0',
      port: 9876
    };

    this.gatewayConfig.apiEndpoints['admin'] = {
      host: this.adminHost
    };

    this.gatewayConfig.serviceEndpoints['admin'] = {
      url: 'http://localhost:9876'
    };
    this.gatewayConfig.pipelines['admin'] = {
      apiEndpoints: [
        'admin'
      ],
      policies: [
        {
          cors: [
            {
              action: {
                credentials: true,
                origin: ADMIN_CROSS_ORIGIN
              }
            }
          ]
        },
        {
          proxy: [
            {
              action: {
                changeOrigin: true,
                serviceEndpoint: 'admin'
              }
            }
          ]
        }
      ]
    };
  }

  getConfigFiles () {
    debug('CONFIG', this.gatewayConfig);

    return {
      'gateway.config.yml': jsYaml.dump(this.gatewayConfig),
      'system.config.yml': jsYaml.dump(Object.assign({}, defaultSystemConfig, this.systemConfig)),
      'users.json': defaultModels['users.json'],
      'applications.json': defaultModels['applications.json'],
      'credentials.json': defaultModels['credentials.json']
    };
  }

  getInitContainersSpec () {
    return [{
      name: "copy-ro-configmap",
      image: "alpine",
      command: [
        "sh",
        "-c",
        "cp /tmp/gateway.config.yml /usr/src/app/lib/config/gateway.config.yml && cp /tmp/system.config.yml /usr/src/app/lib//config/system.config.yml && cp /tmp/users.json /usr/src/app/lib/config/models/users.json && cp /tmp/applications.json /usr/src/app/lib/config/models/applications.json && cp /tmp/credentials.json /usr/src/app/lib/config/models/credentials.json "
      ],
      volumeMounts: [
        {
					mountPath: "/tmp/system.config.yml",
					name: "ro-configmap",
					subPath: "system.config.yml"
				},
				{
					mountPath: "/tmp/gateway.config.yml",
					name: "ro-configmap",
					subPath: "gateway.config.yml"
				},
				{
					mountPath: "/tmp/users.json",
					name: "ro-configmap",
					subPath: "users.json"
				},
				{
					mountPath: "/tmp/applications.json",
					name: "ro-configmap",
					subPath: "applications.json"
				},
				{
					mountPath: "/tmp/credentials.json",
					name: "ro-configmap",
					subPath: "credentials.json"
        },
        {
          mountPath: "/usr/src/app/lib/config",
          name: "config"
        },
        {
          mountPath: "/usr/src/app/lib/config/models",
          name: "config"
        }
      ]
    }];
  }

  getConfigFiles () {
    debug('CONFIG', this.gatewayConfig);

    return {
      'gateway.config.yml': jsYaml.dump(this.gatewayConfig),
      'system.config.yml': jsYaml.dump(Object.assign({}, defaultSystemConfig, this.systemConfig)),
      'users.json': defaultModels['users.json'],
      'applications.json': defaultModels['applications.json'],
      'credentials.json': defaultModels['credentials.json']
    };
  }

  getVolumes (configMap) {
    return [{
      name: 'ro-configmap',
      configMap: {
        name: configMap.metadata.name
      }
    },
    {
      name: 'config',
      emptyDir: {}
    }];
  }

  getContainerSpec () {
    const version = usersInDebugMode.indexOf(this.producer) === -1 ? GATEWAY_VERSION : DEBUG_GATEWAY_VERSION;

    return [{
      name: 'gateway',
      image: `${GATEWAY_IMAGE}:${version}`,
      imagePullPolicy: 'Always',
      readinessProbe: {
        tcpSocket: {
          port: 8080
        },
        initialDelaySeconds: 5,
        timeoutSeconds: 10,
        periodSeconds: 10,
        successThreshold: 2,
        failureThreshold: 3
      },
      env: [
        {
          name: 'LB_PRODUCER',
          value: this.producer
        },
        {
          name: 'EG_CONFIG_DIR',
          value: '/usr/src/app/lib/config'
        },
        {
          name: 'LOG_LEVEL',
          value: 'debug'
        },
        {
          name: 'REDIS_HOST',
          value: process.env.REDIS_HOST || 'eg-identity-redis.default'
        },
        {
          name: 'REDIS_PORT',
          value: process.env.REDIS_PORT || '6379'
        },
        {
          name: 'REDIS_PASSWORD',
          value: process.env.REDIS_PASSWORD
        },
        {
          name: 'EG_NAMESPACE',
          value: `EG-${this.producer}-${this.env}-`
        }

      ],
      ports: [
        {
          name: 'gateway',
          containerPort: 8080
        },
        {
          name: 'admin',
          containerPort: 9876
        }
      ],
      volumeMounts: [{
        name: 'config',
        mountPath: '/usr/src/app/lib/config/system.config.yml',
        subPath: 'system.config.yml'
      }, {
        name: 'config',
        mountPath: '/usr/src/app/lib/config/gateway.config.yml',
        subPath: 'gateway.config.yml'
      }, {
        name: 'config',
        mountPath: '/usr/src/app/lib/config/models/users.json',
        subPath: 'users.json'
      }, {
        name: 'config',
        mountPath: '/usr/src/app/lib/config/models/applications.json',
        subPath: 'applications.json'
      }, {
        name: 'config',
        mountPath: '/usr/src/app/lib/config/models/credentials.json',
        subPath: 'credentials.json'
      }]
    }];
  }

  getServicePorts () {
    return [{
      name: 'gateway',
      port: 8080,
      targetPort: 8080,
      protocol: 'TCP'
    },
    {
      name: 'admin',
      port: 9876,
      targetPort: 9876,
      protocol: 'TCP'
    }];
  }

  getPartialLocator () {
    return {
      producer: this.producer,
      environment: this.env,
      id: this.id,
      instance: slug(this.name),
      app: 'gateway'
    };
  }

  getIngressRules (serviceName, domain) {
    return [{
      host: `${this.slug}.${domain}`,
      http: {
        paths: [{
          backend: {
            serviceName: serviceName,
            servicePort: 8080
          }
        }]
      }
    }, {
      host: `admin-${this.slug}.${domain}`,
      http: {
        paths: [{
          backend: {
            serviceName: serviceName,
            servicePort: 8080
          }
        }]
      }
    }];
  }

  getAnnotations () {
    return {
      'prometheus.io/scrape': 'true',
      'prometheus.io/port': '9876'
    };
  }
}
